% -*- mode: latex; -*- mustache tags:  
\documentclass[10pt,twoside,english]{_support/latex/sbabook/sbabook}
\let\wholebook=\relax

\usepackage{import}
\subimport{_support/latex/}{common.tex}

%=================================================================
% Debug packages for page layout and overfull lines
% Remove the showtrims document option before printing
\ifshowtrims
  \usepackage{showframe}
  \usepackage[color=magenta,width=5mm]{_support/latex/overcolored}
\fi


% =================================================================
\title{A PharoThings Tutorial}
\author{Allex Oliveira}
\series{Square Bracket tutorials}

\hypersetup{
  pdftitle = {A PharoThings Tutorial},
  pdfauthor = {Allex Oliveira},
  pdfkeywords = {IoT, Raspberry, PharoThings, Pharo}
}


% =================================================================
\begin{document}

% Title page and colophon on verso
\maketitle
\pagestyle{titlingpage}
\thispagestyle{titlingpage} % \pagestyle does not work on the first one…

\cleartoverso
{\small

  Copyright 2017 by Allex Oliveira.

  The contents of this book are protected under the Creative Commons
  Attribution-ShareAlike 3.0 Unported license.

  You are \textbf{free}:
  \begin{itemize}
  \item to \textbf{Share}: to copy, distribute and transmit the work,
  \item to \textbf{Remix}: to adapt the work,
  \end{itemize}

  Under the following conditions:
  \begin{description}
  \item[Attribution.] You must attribute the work in the manner specified by the
    author or licensor (but not in any way that suggests that they endorse you
    or your use of the work).
  \item[Share Alike.] If you alter, transform, or build upon this work, you may
    distribute the resulting work only under the same, similar or a compatible
    license.
  \end{description}

  For any reuse or distribution, you must make clear to others the
  license terms of this work. The best way to do this is with a link to
  this web page: \\
  \url{http://creativecommons.org/licenses/by-sa/3.0/}

  Any of the above conditions can be waived if you get permission from
  the copyright holder. Nothing in this license impairs or restricts the
  author's moral rights.

  \begin{center}
    \includegraphics[width=0.2\textwidth]{_support/latex/sbabook/CreativeCommons-BY-SA.pdf}
  \end{center}

  Your fair dealing and other rights are in no way affected by the
  above. This is a human-readable summary of the Legal Code (the full
  license): \\
  \url{http://creativecommons.org/licenses/by-sa/3.0/legalcode}

  \vfill

  % Publication info would go here (publisher, ISBN, cover design…)
  Layout and typography based on the \textcode{sbabook} \LaTeX{} class by Damien
  Pollet.
}


\frontmatter
\pagestyle{plain}

\tableofcontents*
\clearpage\listoffigures

\mainmatter


In this booklet we will show you how to develop a little application that collect weather information. 
We will start to show how we can play with leds and others. 
\chapter{Installations }
The first step you need to do to get started with PharoThings is to install an Operating System in your Raspberry Pi. When you buy a Raspberry Pi, the OS is not factory installed.

Raspbian is the Foundation’s official supported operating system, a Linux OS based on Debian Stretch to run in ARM processors.

Once you've installed the Raspbian, you can install PharoThings and control devices remotely. 
\section{Installing PharoThings on Raspberry Pi}
Install PharoThings requires to get Pharo, PharoThings and an ARM virtual machine. We will build the image on our local computer with the correct files and after we will copy to a Raspberry Pi and execute it there. In the third step, we will connect the Pharo from the local computer into Pharo of Raspberry Pi.
\subsection{Download PharoLauncher}
Use the PharoLauncher (an application to help you running multiple versions and images of Pharo) and install Pharo 6.1. You can get the launcher from \url{http://pharo.org/download}.
You can also directly install a version of Pharo from the same place.


\begin{figure}

\begin{center}
\includegraphics[width=0.6\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap1GettingStarted/figures/InstallLauncher.png}\caption{Installing PharoLauncher.\label{installLauncher}}\end{center}
\end{figure}

\subsection{Download Pharo 61}
Run the Pharo Launcher. Double click the distribution you want to create a image and give a name to image (see Figure \ref{InstallPharo61}). A short name and without spaces is recommended, because we will type this name and path in command line on Linux. 


\begin{figure}

\begin{center}
\includegraphics[width=0.6\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap1GettingStarted/figures/Select61.png}\caption{Download Pharo 61.\label{InstallPharo61}}\end{center}
\end{figure}

\subsection{Execute your Pharo image}
Launch the image as shown in Figure \ref{Execute61}. A folder with the image name will be created inside the folder Pharo:  \textcode{/Users/your\_user\_name/Documents/Pharo/}

In this example the folder is  \textcode{/Users/my\_user\_name/Documents/Pharo/Pharo6.1}


\begin{figure}

\begin{center}
\includegraphics[width=0.6\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap1GettingStarted/figures/Execute61.png}\caption{Open your Pharo image.\label{Execute61}}\end{center}
\end{figure}

\subsection{Load PharoThings}
Open Playground and execute this command to install the server part of PharoThings (as shown in Figure \ref{LoadingPharoThings}):

\begin{displaycode}{plain}
Metacello new
	baseline: 'PharoThings';
	repository: 'github://pharo-iot/PharoThings/src';
	load: #(RemoteDevServer Raspberry).
\end{displaycode}


\begin{figure}

\begin{center}
\includegraphics[width=0.6\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap1GettingStarted/figures/LoadingPharoThings.png}\caption{Loading PharoThings.\label{LoadingPharoThings}}\end{center}
\end{figure}


Then configure image to disable slow browser plugins (instead remote browser will be much slower):

\begin{displaycode}{plain}
ClySystemEnvironmentPlugin disableSlowPlugins.
\end{displaycode}
\subsection{Snapshot your Image}
 In Pharo, click and “Save and Quit”. This way all your code and configurations are saved and ready to be reused.
 
 
\subsection{Download the VM}
\begin{itemize}
\item Download ArmVM from \url{http://files.pharo.org/vm/pharo-spur32/linux/armv6/latest.zip}.
\item Unzip it
\item Copy the files shown in FIgure \ref{CopyARM}  to Pharo folder \textcode{/Users/your\_user\_name/Documents/Pharo/pharo\_image\_folder} 
\end{itemize}


\begin{figure}

\begin{center}
\includegraphics[width=0.6\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap1GettingStarted/figures/CopyARM.png}\caption{Copying PharoARM.\label{CopyARM}}\end{center}
\end{figure}

\subsection{Copying Sources}
Copy the file PharoV60.sources from the folder \textcode{/Applications/Pharo.app/Contents/MacOS} to folder \textcode{/Users/your\_user\_name/Documents/Pharo/images/pharo\_image\_folder/lib/pharo/5.0-201804182009/}
\subsection{Copy to the Raspberry}
Copy this folder to your Raspberry Pi (via flashdrive, network etc). The folder must have the structure shown in Figure \ref{OnRasp}.


\begin{figure}

\begin{center}
\includegraphics[width=0.6\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap1GettingStarted/figures/OnRasp.png}\caption{Copying the folder on your Raspberry.\label{OnRasp}}\end{center}
\end{figure}

\section{Execute PharoThings on Raspberry}\subsection{Turn on your Raspberry and connect it to the network.}
In this example, the folder Pharo6.1 was copied to folder \textcode{/home/pi/}.

Is necessary apply execute permissions on the Pharo files, using the command chmod +x

\begin{displaycode}{plain}
chmod +x /home/pi/Pharo6.1/pharo

chmod +x /home/pi/Pharo6.1/lib/pharo/5.0-201804182009/pharo
\end{displaycode}
\subsection{Start Server}
Start the Pharo typing the following command in the Terminal on your Raspberry :

\begin{displaycode}{plain}
pharo --headless Server.image remotePharo --startServerOnPort=40423
\end{displaycode}

If all is right, you will see the answer:

\begin{displaycode}{plain}
'a TlpRemoteUIManager is registered on port 40423'
\end{displaycode}

So now we have the Raspberry running the TelePharo on TCP port 40423 (as shown in Figure \ref{Commandline}) and we can connect into it from another computer.


\begin{figure}

\begin{center}
\includegraphics[width=0.6\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap1GettingStarted/figures/Commandline.png}\caption{Server up and running.\label{Commandline}}\end{center}
\end{figure}

\section{Connecting Pharo client on remote Pharo}
Open again the Pharo on your local computer and execute this command to install the PharoThings client:

\begin{displaycode}{plain}
Metacello new
baseline: 'PharoThings';
repository: 'github://pharo-iot/PharoThings/src';
load: 'RemoteDev'.
\end{displaycode}

Type this command to connect to the remote TelePharo on Raspberry (change the IP to your Raspberry IP):

\begin{displaycode}{plain}
remotePharo := TlpRemoteIDE connectTo: (TCPAddress ip: #[193 51 236 167] port: 40423)
\end{displaycode}

Here we are using specialized Raspberry tools. They require the auto-refresh feature of inspector which is not enabled by default in Pharo 6. To activate it evaluate:

\begin{displaycode}{plain}
GTInspector enableStepRefresh
\end{displaycode}

So for your board model you need to choose an appropriate board class. For Raspberry, it will be one of the RpiBoard subclasses. Currently, you can use the following classes according to the models:

\begin{itemize}
\item RpiBoardBRev1: Raspberry Pi Model B Revision 1
\item RpiBoardBRev2: Raspberry Pi Model B Revision 2
\item RpiBoard3B: Raspberry Pi Model B+, Pi2 Model B, Pi3 Model B, Pi3 Model B+
\end{itemize}

With the chosen class evaluate the following code to open an inspector:

\begin{displaycode}{plain}
remoteBoard := remotePharo evaluate: [ RpiBoard3B current].
remoteBoard inspect.
\end{displaycode}

And will be open the inspector showing the PIN scheme (as shown in Figure \ref{PharoThingsinspector})


\begin{figure}

\begin{center}
\includegraphics[width=0.6\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap1GettingStarted/figures/PharoThingsInspector.png}\caption{Remote GPIO inspector\label{PharoThingsinspector}}\end{center}
\end{figure}

\subsection{GPIOs}
The board inspector shows a layout of pins similar to Raspberry Pi docs. But here it is a live tool which represents the current pins state.

In the picture the board is shown with two configured pins: gpio3 and gpio4, which are connected to physical button and led accordingly.

Digital pins are shown with green/red icons which represent high/low (1/0) values. In case of output pins you are able to click on the icon to toggle the value. Icons are updated according to pin value changes. If you click on physical button on your board the inspector will show the updated pin state by changing its icon color.

The evaluation pane in the bottom of the inspector provides bindings to gpio pins which you can script by \#doIt/printIt commands. The example shows expressions which were used to configure a button and led.
\section{In the next chapter}
Now that we have installed the Operation System and PharoThings in the Raspberry Pi, we can play with LEDs, sensors, LCD displays and more. 

In the next chapter we will see how turing on/off a LED using PharoThings. 
\chapter{Lesson 1 – Turning LED on/off}
One of the classic analogies in electronics to “Hello World” is turn on a led or lamp. In this first lesson, we will learn how to connect correctly an LED to your Raspberry Pi and how to use PharoThings to control this led by turning it on and off.

Coding in Pharo is very simple, but it is very powerful and you can control all the GPIOs of your Raspberry Pi remotely.

If you did not yet see how to install the PharoThings on your Raspberry Pi and how to control it remotely, you can find the instructions in Chapter 1.
\section{What do we need?}
In this lesson we will use a very simple setup.
\subsection{Components}
\begin{itemize}
\item 1 Raspberry Pi connected to your network (wired or wireless)
\item 1 Breadboard
\item 1 LED
\item 1 Resistor (330ohms)
\item Jumper wires
\end{itemize}
\section{Experimental theory}
Before constructing any circuit, you must know the parameters of the components in the circuit, such as their operating voltage, operating circuit, etc.
\subsection{The LED}
To turn on the LED, we need to send the correct voltage and current to it. The voltage and current can’t be too high, otherwise, the led will burn, or in some cases, damage the Raspberry.

Typically, the forward voltage of an LED is between 1.8 and 3.3 volts. It varies by the color of the LED. A red LED typically drops 1.8 volts, but voltage drop normally rises as the light frequency increases, so a blue LED may drop from 3 to 3.3 volts{[}1{]}.

Most 3mm and 5mm LEDs will operate close to their peak brightness at a drive current of 20 mA. This is a conservative current: it doesn’t exceed most ratings (your specs may vary, or you may not have any specs–in this case, 20 mA is a good default guess {[}2{]})

In this experiment, the operating voltage of the LED is between 1.5V and 2.0V and the operating current is between 10mA and 20mA.
\subsection{The Resistor}
We must always use resistors to connect LEDs up to the GPIO pins of the Raspberry Pi to limit the voltage and current between the LED and the Raspberry to a safe value.

A small change in voltage can produce a huge change in current (see more: LED Current vs. Voltage {[}2{]})

In this experiment, we will use a 330ohm resistor. To identify the correct resistor, follow one of the following color sequences, depending on the number of bands {[}3{]}:

\begin{itemize}
\item If there are four colour bands, they will be Orange, Orange, Brown, and then Gold;
\item If there are five bands, then the colours will be Orange, Orange, Black, Black, Brown.
\end{itemize}

It does not matter which way round you connect the resistors (in this experiment). Current flows in both ways through them. This means that you can connect the resistor at the positive pole or the negative pole of the LED, as well as starting with the first or last color, as shown in the Picture \ref{Ledpolarity}.

But the LEDs will only work if the power is supplied correctly (if the polarity is correct). You will not burn the LEDs if they connect the wrong way – they just will not turn on.


\begin{figure}

\begin{center}
\includegraphics[width=0.6\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap2LED/figures/pharothings-led-polarity-resistors.png}\caption{Led polarity and resistors.\label{Ledpolarity}}\end{center}
\end{figure}

\subsection{The Breadboard}
A breadboard is used to build prototyping of electronics. With a breadboard, it is not necessary to use solder, this way you can reuse the board. This makes it easy to use to create temporary prototypes and experiment with circuit design.

The holes in the breadboard are connected following a pattern, as shown in the Picture \ref{Breadboard}.

\begin{itemize}
\item The red (+) and blue (-) rail are connected horizontally;
\item The holes in the middle are connected vertically.
\end{itemize}


\begin{figure}

\begin{center}
\includegraphics[width=0.6\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap2LED/figures/pharothings-breadboard.png}\caption{Breadboard scheme.\label{Breadboard}}\end{center}
\end{figure}

\section{Experimental procedure}
Now we will build the circuit. This circuit consists of an LED that lights up when power is applied, a resistor to limit current and a power supply (the Rasp).

\begin{itemize}
\item Connect the Ground PIN from Raspberry in the breadboard blue rail (-). Raspeberry Pi models with 40 pins has 8 GPIO ground pins. You can connect with anyone. In this experiment we will use the PIN6 (Ground);
\item Then connect the resistor from the blue rail on the breadboard (-) to a column on the breadboard, as shown in the Picture \ref{physicalLed};
\item Now push the LED legs into the breadboard, with the long leg (with the kink) on the right;
\item And insert a jumper wire connecting the rigth column and the PIN7 (GPIO7).
\end{itemize}

The Figure \ref{physicalLed} shows how the electric connection is made:


\begin{figure}

\begin{center}
\includegraphics[width=0.6\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap2LED/figures/pharothings-raspberry-led-resistor-lesson-01.png}\caption{Physical connection LED.\label{physicalLed}}\end{center}
\end{figure}

\section{Experimental code}


Now, we can write some code in Pharo to control the GPIOs using PharoThings and turn the LED on. We have 2 options to do this:

\begin{itemize}
\item Write the code locally on the Raspberry;
\item Use TelePharo to connect from your computer into the Raspberry and do all the work remotely.
\end{itemize}

In this experiment, we will use the second option: connect and do all the work remotely. 

If you didn’t see how to install the PharoThings on your Raspberry Pi and how to control it remotely, take a look in the Chapter 1: Installations.
\subsection{Connecting remotely}
Through your local Pharo image, let's connect in the Pharo image running on Raspberry, enable the auto-refresh feature of the inspector and open the inspector. Run this code in your local playground:

\begin{displaycode}{plain}
remotePharo := TlpRemoteIDE connectTo: (TCPAddress ip: #[193 51 236 167] port: 40423)
GTInspector enableStepRefresh
remoteBoard := remotePharo evaluate: [ RpiBoard3B current].
remoteBoard inspect.
\end{displaycode}

In your inspect window (Inspector on a PotRemoteBoard) you can see a scheme of pins similar to the Raspberry Pi docs. But here it is a live tool which represents the current pins state.


\begin{figure}

\begin{center}
\includegraphics[width=0.6\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap2LED/figures/pharothings-inspector-remote-board-raspberry.png}\caption{Remote Board Inspector.\label{remoteBoard}}\end{center}
\end{figure}


Digital pins are shown with green/red icons which represent high/low (1/0) values. In case of output pins you are able to click on the icon to toggle the value.

To control the led we first introduce the named variable \#led which we assigned to GPIO7 pin instance:

\begin{displaycode}{plain}
led := gpio7.
\end{displaycode}

Then we configure the pin to be in digital output mode and set the value:

\begin{displaycode}{plain}
led beDigitalOutput.
led value: 1.
\end{displaycode}

It turnes the led on.

You can notice that gpio variables are not just numbers/ids. PharoThings models boards with first class pins. They are real objects with behaviour. For example you can ask pin to toggle a value:

\begin{displaycode}{plain}
led toggleDigitalValue.
\end{displaycode}

Or ask a pin for current value if you want to check it:

\begin{displaycode}{plain}
led value.
\end{displaycode}
\section{What did we learn?}
With PharoThings you can remotely control all the GPIOs in your running board!

You can:

\begin{itemize}
\item Interact remotely with pins and boards;
\item See the current pins state in real time;
\item Run the code dynamically.
\item Easy, powerful.
\end{itemize}
\section{In the next lesson}
Let’s use what we learned in this lesson and write a simple code to blink the LED.
\chapter{Lesson 2 – Blinking LED }
Now we can play with the LEDs, turn them on and off. Let's use this basic setup to write some code on the inspector playground to blink the LED. Next, we will learn how to remotely create a very simple application using classes, methods, and instances to control the LED.
\section{What do we need?}
We are using the same setup as the last section: 1 Raspberry Pi, 1 Breadboard, 1 LED, 1 Resistor 330ohms. If you didn't do the last lesson to understand how to do the connections, go back to Chapter 2 and do it.
\subsection{Connecting remotely}
Through your local Pharo image, let's connect to the Pharo image by running on Raspberry, enable the auto-refresh feature of the inspector, and open the inspector.

Run this code in your local playground:

\begin{displaycode}{plain}
remotePharo := TlpRemoteIDE connectTo: (TCPAddress ip: #[193 51 236 212] port: 40423)
GTInspector enableStepRefresh.
remoteBoard := remotePharo evaluate: [ RpiBoard3B current].
remoteBoard inspect.
\end{displaycode}
\section{Experimental code}
In your inspect window (Inspector on a PotRemoteBoard), let's initialize the led and set the pin 7 to be in digital output mode as we did in the last lesson:

\begin{displaycode}{plain}
led := gpio7.
led beDigitalOutput.
\end{displaycode}

To blink the LED let's create a simple loop to change the value of the LED every 1 second by 10 times. To change the value of the object (led value), let's call the method \textcode{toggleDigitalValue}, as we saw previously:

\begin{displaycode}{plain}
[ 10 timesRepeat: [
	led toggleDigitalValue.
 	(Delay forSeconds: 1) wait
] ] forkNamed: 'BlinkerProcess'.
\end{displaycode}

Run this code, as shown in Figure \ref{RemoteInspector} and... \textcode{cool}! Now your LED is blinking!


\begin{figure}

\begin{center}
\includegraphics[width=0.7\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap3BlinkingLED/figures/pharothings-board-inspector-blink-led.png}\caption{Remote playground.\label{RemoteInspector}}\end{center}
\end{figure}


Change the values to repeat more times and to wait less time between toggling. This will cause the LED to blink faster.
\section{In the next lesson}
In this tutorial, you learned how to blink a LED by typing some code in the remote inspector. But with Pharo we can do more! And in the next lesson, let’s start to use OOP (object-oriented programming). Let's create a simple application, write classes and methods, all remotely.
\chapter{Lesson 3 – A brief introduction to Pharo object-oriented language}
Pharo is a new generation reflective language and programming environment. The last code was executed inside the remote inspector. To get started using OOP (Object-Oriented Programming) with classes, methods, and instances, I invite you to implement a simple application to blink the LEDs.
\section{Developing a simple LED blinker}
The following part of this chapter and application was based on the exercise \textcode{Developing a Simple Counter}, of Week 1 of Pharo MOOC (https://mooc.pharo.org/). I strongly recommend that you read and do the \symbol{34}counter exercise\symbol{34} to better understand the concepts explained here. And, of course, do the MOOC to learn how to develop using Pharo and the OOP concept.
\section{Our use case}
We want to create a blinker LED using a few parameters such as time to repeat the blinking LED and how many seconds to wait between blinks. The following code should run in the playground when we finish this lesson:

\begin{displaycode}{plain}
|blinker|
blinker := Blinker new.
blinker timesRepeat: 10 waitForSeconds: 1.
\end{displaycode}

Here is a short explanation of this code:

\begin{itemize}
\item In the first line, we declare the variable \textcode{blinker}. We can use any name. We will use this variable to create an object using the Blinker class;
\item In the second line, we instantiate the Blinker class (with uppercase B) in the \textcode{blinker} variable, creating an object. In this lesson, we will create this class and methods to control the LED;
\item In the third line, we send some messages to the \textcode{blinker} object, for how long and how many times per second. This will make the GPIO behave according to the parameters sent.
\end{itemize}

Now we will develop all the mandatory class and methods to support this scenario.
\section{Create your own class remotely}
Let's create our first class. To create a class in Pharo, we need first to create a package. Inside the package, you can create many classes and inside the classes, you can create many methods. The methods are organized in protocols, to become more easily navigate between them. Take a look in Figure \ref{RemoteBrowser} to better understanding. *edit image, put name in windows

In your local playground, call the Remote System Browser of your Raspberry Pi. If you are already connected to your Raspberry Pharo, you do not need to run the first line below again. This will open a window as shown in Figure \ref{RemoteBrowser} 


\begin{figure}

\begin{center}
\includegraphics[width=1.0\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap4IntroductiontoPharoOOP/figures/pharothings-remote-system-browser.png}\caption{Remote System Browser.\label{RemoteBrowser}}\end{center}
\end{figure}


\begin{displaycode}{plain}
remotePharo := TlpRemoteIDE connectTo: (TCPAddress ip: #[193 51 236 212] port: 40423).
remotePharo openBrowser.
\end{displaycode}
\section{Create a package}
Let's create a package using the Remote Browser. Right-click the package area and enter the package name, as shown in Figure \ref{CreatingPackage}. In this example, we will create a package named \textcode{PharoThings-Lessons}.


\begin{figure}

\begin{center}
\includegraphics[width=1.0\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap4IntroductiontoPharoOOP/figures/pharothings-creating-package.png}\caption{Creating a package remotely.\label{CreatingPackage}}\end{center}
\end{figure}

\section{Create a class}
To create a new class, edit the default class template by changing the \#NameOfSubclass to the name of the new class. In this example let's create the class \textcode{\#Blinker}. Take care that the class name begins with a capital letter and that you do not remove the hash symbol (\#) in front of NameOfSubClass. 

You must then fill in the names of the instance variables for this class. We need an instance variable called \textcode{led}. Be careful to leave the string quotes!

\begin{displaycode}{plain}
Object subclass: #Blinker
  instanceVariableNames: 'led'
  classVariableNames: ''
  package: 'PharoThings-Lessons'
\end{displaycode}

Now we need to compile it. Right click on the code area and select Accept option. The \textcode{Blinker} class is now compiled and added to the system, as shown in Figure \ref{CreatingClass}.


\begin{figure}

\begin{center}
\includegraphics[width=1.0\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap4IntroductiontoPharoOOP/figures/pharothings-creating-class}\caption{Creating a class remotely.\label{CreatingClass}}\end{center}
\end{figure}

\section{Create a protocol}
Let's create a new protocol to organize the methods. The first protocol we are going to create is \textcode{initialization}, as shown in Figure \ref{CreatingProtocol}.


\begin{figure}

\begin{center}
\includegraphics[width=1.0\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap4IntroductiontoPharoOOP/figures/pharothings-creating-protocol}\caption{Creating a package remotely.\label{CreatingProtocol}}\end{center}
\end{figure}

\section{Creating an initialize method}
Inside this protocol, we will create a \textcode{initialize} method. This means that every time we create a new object using this class, in this case, the Blinker class, this method will be executed to define some variable in the new object.

Let's use the instance variable \textcode{led}, which we defined when we created the class. The instance variable is private to the object and accessible by any methods inside this class. These methods can access this variable to get or set any value to it.

\begin{displaycode}{plain}
initialize 
  led := PotClockGPIOPin id: 4 number: 7. 
  led board: RpiBoard3B current; beDigitalOutput
\end{displaycode}

Here is a short explanation of this code:

\begin{itemize}
\item The first line defines the name of the method;
\item In the second line, we configure the GPIO that we wanna use. Note that we need the GPIO number and ID. The ID is required to communicate with Wiring Pi Library. You can see the \textcode{ID} and \textcode{GPIO number} in PotRemoteBoard inspector, as shown in Figure \ref{RemoteInspector};
\item In the third line, we define the model of the Raspberry board and configure this GPIO as beDigitalOutput. This means that when the GPIO change to value:1, the power will go out of the GPIO to power the LED.
\end{itemize}


\begin{figure}

\begin{center}
\includegraphics[width=0.7\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap4IntroductiontoPharoOOP/figures/pharothings-board-inspector-id-number.png}\caption{Looking for ID and GPIO number on Remote Inspector.\label{RemoteInspector}}\end{center}
\end{figure}


Compile your code (cmd + S) and the method will be shown in the remote browser, as shown in Figure \ref{InitializeMethod}:


\begin{figure}

\begin{center}
\includegraphics[width=1.0\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap4IntroductiontoPharoOOP/figures/pharothings-creating-method-initialize.png}\caption{Creating the initialize method.\label{InitializeMethod}}\end{center}
\end{figure}

\subsection{Creating a method to do actions}
Now let's create a method to control the object led inside the class Blinker. Let's take the code that we used in PotRemoteBoard inspector to do the LED to blink and replace the numbers on code for two arguments. Create the protocol \textcode{operations} and inside this protocol, create the following method:

\begin{displaycode}{plain}
timesRepeat: anInteger waitForSeconds: aNumber
    [ anInteger timesRepeat: [  
        led toggleDigitalValue. 
        (Delay forSeconds: aNumber) wait  
    ] ] forkNamed: 'BlinkerProcess'.
\end{displaycode}

Here is a short explanation of this code:

\begin{itemize}
\item In the first line, we define the message with timesRepeat: and waitForSeconds:. We inform the kind of value will be received, creating 2 variables: aNumber and anInteger;
\item We replace these variables in the code and now we have the control to say how many times repeat and for how many seconds;
\item We finished the code by putting everything inside a fork to create a process in Pharo. While the process is running, you can open the Remote Process Browser (remotePharo openProcessBrowser) and see the process. This is useful when you wanna kill the remote process.
\end{itemize}

Compile your code (cmd + S) and  the method will be shown in the remote browser, as shown in Figure \ref{OperationsMethod}:


\begin{figure}

\begin{center}
\includegraphics[width=1.0\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap4IntroductiontoPharoOOP/figures/pharothings-creating-method-operations.png}\caption{Creating an operation method.\label{OperationsMethod}}\end{center}
\end{figure}

\section{Using your new class}
Now we can use the class that we created, the Blinker class. To do this, let's open the Remote Playground:

\begin{displaycode}{plain}
remotePharo openPlayground.
\end{displaycode}

and run the code that we saw in the begin of this lesson:

\begin{displaycode}{plain}
|blinker|
blinker := Blinker new. 
blinker timesRepeat: 10 waitForSeconds: 1.
\end{displaycode}

Run this code, as shown in Figure \ref{RemotePlayground} and... \textcode{cool}! Now your LED is blinking! And the better, you did this using object-oriented programming! 

 You do not need to change your code every time you wanna change these parameters. Just change the messages you send to the object and it will behave as you want.


\begin{figure}

\begin{center}
\includegraphics[width=1.0\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap4IntroductiontoPharoOOP/figures/pharothings-remote-playground-blinker.png}\caption{Remote playground.\label{RemotePlayground}}\end{center}
\end{figure}



\section{Save your work}
Don't forget to save your work remotely. To do this, run this command on your local playground:

\begin{displaycode}{plain}
remotePharo saveImage.
\end{displaycode}
\section{Conclusion}
In this tutorial, you learned how to define packages, classes, and methods. The flow of programming that we chose for this first tutorial is similar to most of the programming languages.

With PharoThings you can remotely develop and manage your Raspberry GPIOs. Very easy and powerful.

In the next lesson, let’s use what we learned in this lesson and write a simple code to flow lights using 8 LEDs.
\chapter{Lesson 4 - LED Flowing Lights}
Now we can play with the LEDs, turn them on, off, and blink. Let's put 8 LEDs on the breadboard and create a code to turn on/off one at a time. Let's use some methods to change the flow direction and control the flow time. As we did in the last lesson, let's write the first code in playground and then create a class with methods to better control the flow of LED lights. 
\section{What do we need?}
We are using the set of the first lesson, but let's use 8 LEDs and 8 resistors and some more jumper wires.
\subsection{Components}
\begin{itemize}
\item 1 Raspberry Pi connected to your network (wired or wireless)
\item 1 Breadboard
\item 8 LEDs
\item 8 Resistors 330ohms
\item Jumper wires
\end{itemize}
\section{Experimental procedure}
We saw in lesson 1 how to connect the LED and resistors on the breadboard. Now let's do the same, but putting more 7 LEDs and resistors on the breadboard. 

\begin{itemize}
\item Connect the Ground PIN from Raspberry in the breadboard blue rail (-). 
\item Then connect the 8 resistors from the blue rail (-) to a column on the breadboard, as shown below;
\item Now push the LED legs into the breadboard, with the long leg (with the kink) on the right;
\item And insert the jumper wires connecting the right column of each LED to GPIO from 0 to 7, as shown in the Picture \ref{Schema8Leds}.
\end{itemize}

The Figure \ref{Physical8Leds} shows how the electric connection is made.


\begin{figure}

\begin{center}
\includegraphics[width=0.6\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap5LEDFlowingLights/figures/pharothings-raspberry-8leds-8resistors-board.jpeg}\caption{Schema connection 8 LEDs.\label{Schema8Leds}}\end{center}
\end{figure}


\begin{figure}

\begin{center}
\includegraphics[width=0.6\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap5LEDFlowingLights/figures/pharothings-raspberry-raspberry-leds-breadboard-01.jpeg}\caption{Physical connection 8 LEDs.\label{Physical8Leds}}\end{center}
\end{figure}

\subsection{Connecting remotely}
Through your local Pharo image, let's connect in the Pharo image by running on Raspberry, enable the auto-refresh feature of the inspector, and open the inspector.

Run this code in your local playground:

\begin{displaycode}{plain}
remotePharo := TlpRemoteIDE connectTo: (TCPAddress ip: #[193 51 236 212] port: 40423)
GTInspector enableStepRefresh.
remoteBoard := remotePharo evaluate: [ RpiBoard3B current].
remoteBoard inspect.
\end{displaycode}
\section{Experimental code}
In your inspect window (Inspector on a PotRemoteBoard), let’s create an array and initialize the 8 LEDs, putting each one in a position of the array.  This way we can send messages more easily to all objects. Look at the second line, we set the GPIOs to \textcode{beDigitalOutput} only using the method \textcode{do:} to move through the entire array:

\begin{displaycode}{plain}
gpioArray := { gpio0. gpio1. gpio2. gpio3. gpio4. gpio5. gpio6. gpio7 }.
gpioArray do: [ :item | item beDigitalOutput ].
\end{displaycode}

To change the value of the object (led value), let's call the method \textcode{toggleDigitalValue}, as we saw previously. You can also use the method \textcode{value:} and send 1 or 0, instead \textcode{toggleDigitalValue}, but let's use this last. To do this fast and simple, let's use again the method \textcode{do:} to send the parameters to all objects on the array. In this example, we turn On all the LEDs at the same time:

\begin{displaycode}{plain}
gpioArray do: [ :item | item toggleDigitalValue ].
\end{displaycode}

Let's put a Delay after changing the led value, to wait a bit time before to change the next LED value.  Let's also put this inside a process using the method \textcode{forkNamed}:

\begin{displaycode}{plain}
[
    gpioArray do: [ :item | item toggleDigitalValue. (Delay forSeconds: 0.3) wait ].
] forkNamed: 'FlowingProcess'.
\end{displaycode}

Execute this code and… cool! Now your LEDs are on by flowing an ordering!

Change the value of the method \textcode{forSeconds}: to wait less time between toggling it. This will cause the line LEDs to turn on faster. The Figure \ref{Inspector8LEDs} and \ref{8LEDs} shows the code and the LEDs turn On.


\begin{figure}

\begin{center}
\includegraphics[width=0.85\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap5LEDFlowingLights/figures/pharothings-raspberry-8leds-code-lesson-01.png}\caption{Code on Inspector\label{Inspector8LEDs}}\end{center}
\end{figure}


\begin{figure}

\begin{center}
\includegraphics[width=0.6\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap5LEDFlowingLights/figures/pharothings-raspberry-raspberry-leds-breadboard-02.jpeg}\caption{LEDs turn On.\label{8LEDs}}\end{center}
\end{figure}

\section{Adding features}
Every time you run this code, the LEDs toggles the state, from Off to On or vice versa. Let’s reduce the delay time and add the \textcode{timesRepeat:} method, as we did in the last lesson, to repeat the alternation as many times as we want:

\begin{displaycode}{plain}
[ 2 timesRepeat: [
    gpioArray do: [ :item | item toggleDigitalValue. (Delay forSeconds: 0.1) wait ].
] ] forkNamed: 'FlowingProcess'.
\end{displaycode}

Execute this code and… cool! Now your LEDs are flowing On and Off!
\section{Reversing the flow}
We can have more fun with this experiment by changing the order of where to start changing the value of LEDs. To do this is very easy, just call the method \textcode{reverseDo:} and it will solve all for you:

\begin{displaycode}{plain}
[ 2 timesRepeat: [
    gpioArray reverseDo: [ :item | item toggleDigitalValue. (Delay forSeconds: 0.1) wait ].
] ] forkNamed: 'FlowingProcess'.
\end{displaycode}

Execute this code and… cool! Now your LEDs are flowing on reverse order!
\section{Going and backing the flow}
To finish this experiment, let’s combine the flowing On and Off with the Reverse!

\begin{displaycode}{plain}
[ 2 timesRepeat: [
    gpioArray do: [ :item | item toggleDigitalValue. (Delay forSeconds: 0.1) wait ].
    gpioArray reverseDo: [ :item | item toggleDigitalValue. (Delay forSeconds: 0.1) wait ].
] ] forkNamed: 'FlowingProcess'.
\end{displaycode}

Execute this code and… cool! Now your LEDs are flowing On and Off and on normal and reverse order!

We can improve this code. Do you see this part where the code is repeating \symbol{34}\textcode{{[} :item \textbar{} item toggleDigitalValue. (Delay forSeconds: 0.1) wait {]}}\symbol{34} ? Let's put this inside a variable named \textcode{action}, so we can call it when we want:

\begin{displaycode}{plain}
action := [ :item | item toggleDigitalValue. (Delay forSeconds: 0.1) wait ].
[ 2 timesRepeat: [
    gpioArray do: action.
    gpioArray reverseDo: action.
] ] forkNamed: 'FlowingProcess'.
\end{displaycode}

We can put the code inside the block closure \symbol{34}{[} {]} in a variable also and call it in just one line. Let's put it inside the variable \textcode{flowing}:

\begin{displaycode}{plain}
action := [ :item | item toggleDigitalValue. (Delay forSeconds: 0.1) wait ].
flowing := [ 2 timesRepeat: [
    gpioArray do: action.
    gpioArray reverseDo: action.
] ].
\end{displaycode}

Now we can start the process just send the method forkNamed: to the object \textcode{flowing}, like in the following line:

\begin{displaycode}{plain}
flowing forkNamed: 'FlowingProcess'.
\end{displaycode}

Your final code will seem like the Picture \ref{Process8LEDs}. Run this code once and when you want to flow the LEDs again, just run the last line. But remember, to each change in the code, you need to run the part that you changed. 

\begin{displaycode}{plain}
gpioArray := { gpio0. gpio1. gpio2. gpio3. gpio4. gpio5. gpio6. gpio7 }.
gpioArray do: [ :item | item beDigitalOutput ].
action := [ :item | item toggleDigitalValue. (Delay forSeconds: 0.1) wait ].
flowing := [ 2 timesRepeat: [
	gpioArray do: action.
	gpioArray reverseDo: action.
] ].
flowing forkNamed: 'FlowingProcess'.
\end{displaycode}


\begin{figure}

\begin{center}
\includegraphics[width=0.85\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap5LEDFlowingLights/figures/pharothings-raspberry-8leds-code-lesson-02.png}\caption{Process Browser terminate.\label{Process8LEDs}}\end{center}
\end{figure}

\section{Terminating the process}
As we saw in the Blinking LED lesson, you can finish this process remotely, case you don’t want to wait it finish. To do this, call the Remote Process Browser:

\begin{displaycode}{plain}
remotePharo openProcessBrowser.
\end{displaycode}

Search the FlowingProcess and terminate it, like in Picture \ref{Inspector8LEDsfinal}, using one of these options:

\begin{itemize}
\item selecting the process and using the shortcut “Cmd + T”;
\item selecting the process and using the button Terminate;
\item or right-click and select Terminate.
\end{itemize}


\begin{figure}

\begin{center}
\includegraphics[width=0.8\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap5LEDFlowingLights/figures/pharothings-raspberry-remoteprocess.png}\caption{Process Browser terminate.\label{Inspector8LEDsfinal}}\end{center}
\end{figure}

\section{In the next lesson}
In this tutorial, you learned how to use an Array and control 8 objects at the same time by typing some code in the remote inspector. But with Pharo we can do more!

You can create your own program in classes and methods using the codes you learned in this lesson. Go ahead and try to do this yourself to test your knowledge.

And in the next lesson, let’s use object-oriented programming, OOP to create a simple program, using these codes, to control the flow like as we want.
\chapter{Lesson 5 - LED Flowing Lights using OOP}
Now we can play with the LEDs, turn them on, off, blink it and manipulate many at the same time. Let’s use object-oriented programming, OOP to create methods and classes, to build a simple program, to control the LEDs flow like as we want.
\section{The goal}
In this chapter we will create a program to control the LEDs with some features:

\begin{itemize}
\item We want to set how many times the LED line will flow;
\item We want to set the speed of this flow;
\item And we want to set the direction if the flow will start from left or right and which order will be executed. For example, if we want to set to flow starting from the right and after the start from left again, we will use the message 'lrl'. The program needs to able to flow in any combination of directions, like llr, rlllrr, rlrlrlr etc.
\end{itemize}

The final code executed in the playground will be a code like this: 

\begin{displaycode}{plain}
leds := Flowing new.
leds times: 2 delay: 0.1 direction: 'lrl'.
leds flowStart.
leds flowStop.
leds turnOn.
leds turnOff.
\end{displaycode}
\section{Creating the class}
\begin{displaycode}{plain}
Object subclass: #Flowing
    instanceVariableNames: 'ledArray flowProcess flowDirection toggleDelay timesRepeat'
    classVariableNames: ''
    package: 'PharoThings-Lessons'
\end{displaycode}
\section{Creating the initialize method}
\begin{displaycode}{plain}
initialize
    ledArray := { 
    (PotGPIOPin id: 17 number: 0).
    (PotGPIOPin id: 18 number: 1).
    (PotGPIOPin id: 27 number: 2).
    (PotGPIOPin id: 22 number: 3).
    (PotGPIOPin id: 23 number: 4).
    (PotGPIOPin id: 24 number: 5).
    (PotGPIOPin id: 25 number: 6).
    (PotGPIOPin id: 4 number: 7)
    }.
   ledArray do: [ :item | item board: RpiBoard3B current; beDigitalOutput; value:0 ].
    timesRepeat := 2.
    toggleDelay := 0.5.
    flowDirection := 'lr'.
\end{displaycode}
\section{Creating access methods}
\begin{displaycode}{plain}
times: anInteger delay: aNumber direction: aString
    timesRepeat := anInteger.
    toggleDelay := aNumber.
    flowDirection := aString
\end{displaycode}

\begin{displaycode}{plain}
flowDirection
    ^flowDirection
\end{displaycode}

\begin{displaycode}{plain}
flowTimesRepeat
    ^timesRepeat
\end{displaycode}

\begin{displaycode}{plain}
toggleDelay
     ^toggleDelay
\end{displaycode}
\section{Creating process control methods}
\begin{displaycode}{plain}
flowStart
    flowProcess := [ (self flowTimesRepeat) timesRepeat: [
          self action
      ] ] forkNamed: 'FlowingProcess'.
\end{displaycode}

\begin{displaycode}{plain}
flowStop
    flowProcess terminate
\end{displaycode}
\section{Creating action methods}
\begin{displaycode}{plain}
action  
flowDirection do: [ :character | character == $l ifTrue: [ ledArray do: self toggleLedArray  ]. 
                        character == $r ifTrue: [ ledArray reverseDdo: self toggleLedArray  ] ] 
\end{displaycode}

\begin{displaycode}{plain}
toggleLedArray
    ^[ :item | item toggleDigitalValue. (Delay forSeconds: self toggleDelay) wait ]
\end{displaycode}

\begin{displaycode}{plain}
turnOn
    ledArray do: [ :item | item value:1 ].
\end{displaycode}

\begin{displaycode}{plain}
turnOff
    ledArray do: [ :item | item value:0 ].
\end{displaycode}
\chapter{Lesson 6 - LED Breathing PWM}\chapter{Lesson 7 - Controlling LED by Button}
In the previous lessons, we learned how to control the GPIOs putting them in mode OUT. This means send power to wire connected in on specific GPIO. Now we will put the GPIO in mode IN, to read the pin state. This means that our application can know when a button is pressed. Let’s create a shortcode on the remote inspector to turn On one LED each time we press the button.
\section{What do we need?}
We are using the set of the first lesson, but let's use 8 LEDs and 8 resistors and some more jumper wires.
\subsection{Components}
\begin{itemize}
\item 1 Raspberry Pi connected to your network (wired or wireless)
\item 1 Breadboard
\item 1 LED
\item 1 Resistor 330ohms
\item 1 Pushbutton
\item Jumper wires
\end{itemize}
\section{Experimental theory}
The Raspberry Pi GPIOs can be set OUT or IN mode. When we set them to IN, the selected pin can have change the state from 0 to 1 or vice-versa when we connect it in the 3.3V or ground PIN.

In this lesson, we will use the pull-up mode with an internal resistor. This means that we will use the 3.3V pin to change the GPIO value. If we used the pull-down mode, we would use the Ground Pin to change the GPIO value. To know more, you can access the Wiring Pi website, http://wiringpi.com/reference/core-functions.

In this scenario, we will put a push button between the 3.3V pin and GPIO pin, to control when to send energy to GPIO.
\section{Experimental procedure}
Now we will build the circuit. This circuit consists of an LED, a resistor to limit current and a push button, to control when to send power to GPIO IN.  

\begin{itemize}
\item Connect the Ground PIN from Raspberry in the breadboard blue rail (-). In this experiment we will use the PIN6 (Ground);
\item Then connect the resistor from the same row on the breadboard to a column on the breadboard, as shown below;
\item Now push the LED legs into the breadboard, with the long leg (with the kink) on the right;
\item And insert a jumper wire connecting the right column and the PIN7 (GPIO7);
\item Connect the 3.3V PIN in the red rail (+);
\item Then insert the push button on the breadboard and connect one leg on PIN11 (GPIO0);
\item And another button leg on the red rail (+). Pay attention to the position of the button!
\end{itemize}

The figure below shows how the electric connection is made:
\section{Connecting remotely}
Through your local Pharo image, let’s connect in the Pharo image by running on Raspberry, enable the auto-refresh feature of the inspector, and open the inspector.
Run this code in your local playground:

\begin{displaycode}{plain}
remotePharo := TlpRemoteIDE connectTo: (TCPAddress ip: #[193 51 236 212] port: 40423)
GTInspector enableStepRefresh.
remoteBoard := remotePharo evaluate: [ RpiBoard3B current].
remoteBoard inspect.
\end{displaycode}
\section{Experimental code}
In your inspect window (Inspector on a PotRemoteBoard), let’s create the instances of the LED and button.

To instantiate the LED, let’s do how we did previous, putting it in beDigitalOutput mode:

\begin{displaycode}{plain}
led := gpio7
led beDigitalOutput.
\end{displaycode}

To instantiate the button let’s do the same, but putting it in beDigitalInput and setting it to enablePullUpResister mode:

\begin{displaycode}{plain}
button := gpio0.
button beDigitalInput.
button enablePullUpResister.
\end{displaycode}

This means each time that we connect the 3.3V on this GPIO (pushing the button), the state will be changed to 1, and back to 0 after release the button.

You ask the value of the button using the value method. Do this test running this line with the button pressed and after with the button released. This test is good for you to check if your button is working correctly:

\begin{displaycode}{plain}
button value.
\end{displaycode}

Now let’s create a process to check when the button is pressed and send this value to led object:

\begin{displaycode}{plain}
[ [100 milliSeconds wait. 
    led value: (button value=1) asBit
        ] repeat    
     ] forkNamed: 'button process'.
\end{displaycode}

Your LED will turn On when the button is pressed!
\section{Terminating the process}
As we saw in the Blinking LED lesson, you can finish this process remotely, case you don’t want to wait it finish. To do this, call the Remote Process Browser:

\begin{displaycode}{plain}
 remotePharo openProcessBrowser.
\end{displaycode}

Search the FlowingProcess and terminate it:

\begin{itemize}
\item selecting the process and using the shortcut “Cmd + T”;
\item selecting the process and using the button Terminate;
\item or right-click and select Terminate.
\end{itemize}
\section{In the next lesson}
In this lesson, you learned how to configure a push button, take the value of the button and send it to LED value, doing the LED turn On or Off using the button.

Next lesson we will start to use the sensors using the I2C protocol. We will see the BME280 (temperature, humidity, and air pressure), ADXL (accelerometer X, Y, Z) and MCP9808 (temperature).
\chapter{Lesson 8 - I2C Sensors (Temperature, Humidity, Pressure and Acellerometer)}
In the previous lessons, we learned how to control LEDs and to use a button to interact with LEDs. Now let's start using some sensors to interact automatically with the real world, taking the temperature, air pressure and humidity This kind of sensor use the I2C protocol to communicate.
\section{What do we need?}
In this lesson, we will use a setup with 3 different I2C sensors.
\subsection{Components}
\begin{itemize}
\item 1 Raspberry Pi connected to your network (wired or wireless)
\item 1 Breadboard
\item 1 BME280 temperature, humidity and pressure sensor
\item 1 MCP9808 temperature sensor
\item 1 ADXL345 accelerometer sensor
\item Jumper wires
\end{itemize}
\section{Experimental theory}
Before constructing any circuit, you must know the parameters of the components in the circuit, such as their operating voltage, operating circuit, etc.
\subsection{The I2C protocol}
The I2C communication protocol can be easily implemented in many electronic projects, being a very popular and widely used protocol. It is possible to perform communication between one or more master devices and several slave devices. It is an easy-to-implement protocol because it uses only 2 wires to communicate between up to 112 devices using 7-bit addressing and up to 1008 devices using 10-bit addressing.

The Figure \ref{I2CBus} shows how you can connect the devices using the same I2C bus.


\begin{figure}

\begin{center}
\includegraphics[width=0.8\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap9I2CSensors/figures/pharothings-i2c-bus.jpg}\caption{Devices connected using I2C bus.\label{I2CBus}}\end{center}
\end{figure}

\subsection{How I2C works?}
How can we communicate with multiple devices using only two wires? For this to happen, each device has set an ID or a unique address. Then the master device can choose which device to communicate with.

The two wires are called Serial Clock (or SCL) and Serial Data (or SDA). The SCL wire is the clock signal that synchronizes the data transfer between devices on the I2C bus and is generated by the master device. The other wire is the SDA line that carries the date.
\subsection{Protocol}
The data is transferred in 8-bit sequences like you can see in Figure \ref{I2CBusPacket}. After a special starting condition occurs, comes the first 8-bit sequence that indicates the address of the slave to which the data is being sent.
For example, for the ADXL345 accelerometer device, the default address is 16r53 (0X53) or 0101 0011 (the last bit activated means the device is on reading mode).

After each 8-bit sequence follows a bit called Acknowledge. After the first Acknowledge bit, in most cases another addressing sequence comes, but this time to the internal registers of the slave device. 

The internal registers are locations in the slave's memory containing various information or data. For example, the ADX345 accelerometer has a unique device address (16r53) and addition internal record addresses for the X, Y, and Z axes (16r32, 16r33, 16r34, etc.). Therefore, if we want to read the X-axis data, we first need to send the address of the device and then the internal register address specific to the X-axis.

After the addressing sequences, the data streams are as many as they are sent until the data is completely sent and ends with a special stop condition.


\begin{figure}

\begin{center}
\includegraphics[width=0.8\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap9I2CSensors/figures/pharothings-i2c-bus-data.png}\caption{Bits sequence.\label{I2CBusPacket}}\end{center}
\end{figure}

\section{Experimental procedure}
Now we will build the circuit. This circuit consists of three sensors (BME280, MCP9808, ADXL345) and a power supply (the Rasp).

\begin{itemize}
\item Connect the Ground PIN from Raspberry in the breadboard blue rail (-). In this experiment we will use the PIN6 (Ground);
\item Then connect the 3.3V (PIN1) pin in the red rail (+). 
\item Now let's connect the SCL (PIN5) and SDA (PIN3) wires. Connect them like as shown in the Figure \ref{physicalSensors} ;
\item Now push the sensors in the breadboard;
\item And insert the jumper wires connecting the sensor in the bus, like as shown in the Figure \ref{physicalSensors};
\item The last step is to connect the power 3.3V (+) and ground (-) wires in each sensor.
\end{itemize}

The Figure \ref{physicalSensors} shows how the electric connection is made.


\begin{figure}

\begin{center}
\includegraphics[width=0.6\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap9I2CSensors/figures/pharothings-sensors-board.png}\caption{Physical sensors connection.\label{physicalSensors}}\end{center}
\end{figure}

\section{Configuring the Raspberry Pi I2C}
We need to configure the Raspberry Pi to use the I2C protocol. To do this, access the Raspberry using SSH and go to file \textcode{/boot/config.txt} and add the line \textcode{dtparam=i2c1=on}.

You can run the follow command to do this:

\begin{displaycode}{plain}
sudo echo dtparam=i2c1=on >> /boot/config.txt
\end{displaycode}

Add the ‘pi’ user to I2C group and restart the Raspberry 

\begin{displaycode}{plain}
sudo adduser pi i2c 
reboot
\end{displaycode}

Now your Raspberry is configured to communicate with the sensor using the I2C protocol. 
\section{Connecting remotely}
Through your local Pharo image, let’s connect in the Pharo image by running on Raspberry, enable the auto-refresh feature of the inspector, and open the inspector.
Run this code in your local playground:

\begin{displaycode}{plain}
remotePharo := TlpRemoteIDE connectTo: (TCPAddress ip: #[193 51 236 212] port: 40423)
GTInspector enableStepRefresh.
remoteBoard := remotePharo evaluate: [ RpiBoard3B current].
remoteBoard inspect.
\end{displaycode}
\section{Exploring the properties of a remote object with the remote inspector}
In your inspect window (Inspector on a PotRemoteBoard), let’s create the instances of the first sensor. 

\begin{displaycode}{plain}
a := board installDevice: PotBME280Device new. ​
\end{displaycode}

With this proceeding, we are creating an object and we can inspect it to see the properties and values. To see the details of this object, like for example what you can do and what you can ask to it (methods), press cmd + I to inspect it and you will see the inspect window. 

In the \textcode{Meta} tab, you can see the Class and Subclass of this object. To see what you can do with this object (methods), you can start selecting the top Class and will be shown in the right window the methods that you can to use.

Let's see what the method \textcode{readParameters} can do. When you select it, you can see the code of method on the bottom of the window. When you call this method, it returns an array with 3 values: temperature, pressure, and humidity. The carrot symbol (little hat ˆ) is to return something when the method is called. 

So let's use the method \textcode{readParameters} to ask to the object what are the values of temperature, pressure, and humidity. To get the return of this object, select the following code and press cmd + P. You will see a big number. This number is an array with 3 indexes like the Figure \ref{inspectorSensor}. 


\begin{figure}

\begin{center}
\includegraphics[width=0.8\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap9I2CSensors/figures/pharothings-inspect-sensor.png}\caption{Inspecting remote object.\label{inspectorSensor}}\end{center}
\end{figure}


\begin{displaycode}{plain}
a readParameters.
\end{displaycode}

To see the details of this object, you can press Cmd + I to inspect it and you will see the 3 indexes separately. 
\section{Getting the temperature with BME280}
You can also ask to only one value, selecting the array index using the method \textcode{at:}. In this case, we are selecting only the index 1 of an array and will return only the temperature:

\begin{displaycode}{plain}
a readParameters at: 1.
\end{displaycode}

If you want to format the number to be more legible, you can use:

\begin{displaycode}{plain}
(a readParameters at: 1) printShowingDecimalPlaces: 2.
\end{displaycode}
\section{Getting the humidity and pressure with BME280}
Now you know how to ask to the object the specific value that you want. To get the humidity and pressure is very simple, just choose the index of each one and format them as you want. To get the pressure:

\begin{displaycode}{plain}
(a readParameters at: 2) printShowingDecimalPlaces: 2.
\end{displaycode}

and to get the humidity:

\begin{displaycode}{plain}
(a readParameters at: 3) printShowingDecimalPlaces: 2.
\end{displaycode}

This is very simple and you can get these values and stored in a variable, to use to different proposes, like send a message to an LCD display, send the values to a cloud server and simply do some action, like for example turn on a LED or turn on an Air Conditional (using relays). In the following example, after you put the temperature value in a temperature variable, you can select the variable and press Cmd + P to see just the temperature. 

\begin{displaycode}{plain}
temperature := (a readParameters at: 1) printShowingDecimalPlaces: 2.
temperature.
\end{displaycode}
\section{Getting the temperature with MCP9808}
How we see before, is very easy to read the values of the sensors. To read the values of the MCP9808 sensor, just create an object using the MCP9808 sensor with the follow code and read the temperature with the method \textcode{readTemperature}:

\begin{displaycode}{plain}
b := board installDevice: PotMCP9808Device new. ​ 
b readTemperature.  
\end{displaycode}

You can format the answer as you want also:

\begin{displaycode}{plain}
(b readTemperature) printShowingDecimalPlaces: 2.
\end{displaycode}
\section{Getting the axis X, Y, and Z with ADXL345}
The process is the same before. Let's create an object with the sensor and ask to it what is the value of the X, Y, Z axis:

\begin{displaycode}{plain}
c := board installDevice: PotADXL345Device new. ​ 
c readCoordinates. 
\end{displaycode}

As like the BME280 sensor, the ADXL345 is returning an array with 3 indexes, the 3 axes. To ask to a specific axis, you can select the position that you want. In the following case we are getting the X-axis:

\begin{displaycode}{plain}
c readCoordinates at: 1.
\end{displaycode}
\section{Conclusion}
In this tutorial, you learned how to inspect remote objects to understand what this object can do. You learned also how to get the value of temperature, humidity and pressure to store in a variable, as like the X, Y, Z axis. 

In the next lesson, let’s see a different kind of sensor, the ultrasonic sensor. It uses only 2 wires to work, but don't use the I2C protocol. See you there.
\chapter{Lesson 9 - Ultrasonic Sensor (Distance)}
In the previous lessons, we learned how to control LEDs and to use a button to interact with LEDs. We learned also how to use the I2C sensors to read the temperature, humidity, pressure, and x, y, z-axis. Now let's use a different kind of sensor, that doesn't use I2C protocol. 
\section{What do we need?}
In this lesson, we will use a setup with an ultrasonic sensor.
\subsection{Components}
\begin{itemize}
\item 1 Raspberry Pi connected to your network (wired or wireless)
\item 1 Breadboard
\item 1 HC-SR04 sensor
\item 1 Resistor (1K ohms)
\item 1 Resistor (2K ohms)
\item Jumper wires
\end{itemize}
\section{Experimental theory}
Before constructing any circuit, you must know the parameters of the components in the circuit, such as their operating voltage, operating circuit, etc.
\subsection{The ultrasonic measure}
The ultrasonic sensor that we will use in this tutorial has 4 PINs: GND Ground, VCC 5V, TRIG to send a pulse and ECHO to show how long time the pulse spend to go and back.  
\subsection{How the HC-SR04 works?}
It uses our Raspberry Pi to send a signal using the TRIG, which triggers the sensor to send an ultrasonic pulse. Pulse waves reflect any nearby objects and some are reflected back to the sensor. The sensor detects these return waves and measures the time between the trigger and the returned pulse and sends a 5V signal on the ECHO pin. So is just to see how long time the ECHO pin will stay ON and calculate the distance because we already know the sound speed. 
\subsection{Limiting the return voltage with resistors}
The ECHO signal in sensor HC-SR04 uses 5V. But the Raspberry Pi PINS uses 3.3V. If we send 5V to Raspberry GPIO, it can damage the Rasp. To avoid this let's put 2 resistors to limit the voltage.  
\section{Experimental procedure}
Now we will build the circuit. This circuit consists of 1 ultrasonic sensor HC-SR04, 1 resistor 1K ohms, 1 resistor 2K ohms and a power supply (the Rasp).

\begin{itemize}
\item Connect the Ground PIN from Raspberry in the breadboard blue rail (-). In this experiment we will use the PIN9 (Ground);
\item Then connect the 5V (PIN2) pin in the red rail (+). 
\item Now push the HC-SR04 sensor in the breadboard;
\item And insert the jumper wires connecting the sensor leg TRIG in the GPIO0 (PIN11) and the sensor leg ECHO in the breadboard, like the scheme shown in the Figure \ref{physicalSonicSensors};
\item The last step is to connect the power 5V and ground (-) wires from the breadboard rails in the sensor VCC + and GND (-) legs.
\end{itemize}

The Figure \ref{physicalSonicSensors} shows how the electric connection is made.


\begin{figure}

\begin{center}
\includegraphics[width=0.6\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap10UltrasonicSensor/figures/pharothings-ultrasonic-board.png}\caption{Physical sensors connection.\label{physicalSonicSensors}}\end{center}
\end{figure}

\section{Connecting remotely}
Through your local Pharo image, let’s connect in the Pharo image by running on Raspberry, enable the auto-refresh feature of the inspector, and open the inspector.
Run this code in your local playground:

\begin{displaycode}{plain}
remotePharo := TlpRemoteIDE connectTo: (TCPAddress ip: #[193 51 236 212] port: 40423)
GTInspector enableStepRefresh.
remoteBoard := remotePharo evaluate: [ RpiBoard3B current].
remoteBoard inspect.
\end{displaycode}
\section{Experimental code}
In your inspect window (Inspector on a PotRemoteBoard), let’s create an instance of the ultrasonic sensor. 

\begin{displaycode}{plain}
d := board installDevice: PotHCSR04Device new. ​ 
\end{displaycode}

As we saw before, we can inspect the remote object to see some properties and methods. Let's use the method \textcode{readDistance} to read the distance: 

\begin{displaycode}{plain}
d readDistance.  
\end{displaycode}
\chapter{Lesson 10 - LCD Display}
In the previous lessons, we learned how to control LEDs and to use a button to interact with LEDs. We learned also how to use the I2C sensors to read the temperature, humidity, pressure, and x, y, z-axis. Also, we saw how to use a no I2C sensor, an ultrasonic sensor. Now we will learn how to use an LCD Display without I2C. 
\section{What do we need?}
In this lesson, we will use a setup with an LCD Display 1602.
\subsection{Components}
\begin{itemize}
\item 1 Raspberry Pi connected to your network (wired or wireless)
\item 1 Breadboard
\item 1 LCD Display 1602 
\item 1 Potentiometer (10K ohms)
\item Jumper wires
\end{itemize}
\section{Experimental theory}
Before constructing any circuit, you must know the parameters of the components in the circuit, such as their operating voltage, operating circuit, etc.
\subsection{The LCD Display 1602}\subsection{How the LCD 1602 works?}\section{Experimental procedure}
Now we will build the circuit. This circuit consists of three sensors and a power supply (the Rasp).

\begin{itemize}
\item Connect the Ground PIN from Raspberry in the breadboard blue rail (-). In this experiment we will use the PIN6 (Ground);
\item Then connect the 5V (PIN2) pin in the red rail (+). 
\item Now push the LCD 1602 in the breadboard;
\item Push the potentiometer in the breadboard;
\item And insert the jumper wires connecting the LCD Display in the Potentiometer and breadboard, as the scheme shown in the Figure \ref{physicalLCD}.
\end{itemize}

The Figure \ref{physicalLCD} shows how the electric connection is made.


\begin{figure}

\begin{center}
\includegraphics[width=0.6\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap11LCDDisplay/figures/pharothings-lcd-board.png}\caption{Physical sensors connection.\label{physicalLCD}}\end{center}
\end{figure}

\section{Connecting remotely}
Through your local Pharo image, let’s connect in the Pharo image by running on Raspberry, enable the auto-refresh feature of the inspector, and open the inspector.
Run this code in your local playground:

\begin{displaycode}{plain}
remotePharo := TlpRemoteIDE connectTo: (TCPAddress ip: #[193 51 236 212] port: 40423)
GTInspector enableStepRefresh.
remoteBoard := remotePharo evaluate: [ RpiBoard3B current].
remoteBoard inspect.
\end{displaycode}
\section{Experimental code}
In your inspect window (Inspector on a PotRemoteBoard), let’s create the instances of the LCD Display. 

\begin{displaycode}{plain}
lcd := board installDevice: PotLCD1602Device new.
\end{displaycode}

As we saw before, we can inspect the remote object to see some properties and methods. Let's use the method \textcode{message:} to send some message to LCD Display. To break line you can use \symbol{34}/n\symbol{34}. And to clear the LCD you can use the method \textcode{clear}:

\begin{displaycode}{plain}
lcd message: 'Hello everybody!\Pharo is cool!'. 
lcd clear.
\end{displaycode}
\chapter{Lesson 11 - Building a Mini-Weather Station}
In the previous lessons, we learned how to control LEDs, sensors, LCD displays and how to use OOP to create applications to control them. Now we will use everything that we learned to build a Mini-Weather Station. 
\section{What do we need?}
In this lesson, we will use a setup with an LCD Display 1602 and BME280 sensor.
\subsection{Components}
\begin{itemize}
\item 1 Raspberry Pi connected to your network (wired or wireless)
\item 1 Breadboard
\item 1 BME280 temperature, humidity and pressure sensor
\item 1 LCD Display 1602 
\item 1 Potentiometer (10K ohms)
\item Jumper wires
\end{itemize}
\section{Experimental theory}
Before constructing any circuit, you must know the parameters of the components in the circuit, such as their operating voltage, operating circuit, etc.

In this lesson, we will get the temperature, pressure, and humidity using the BME280 sensor, show this information on the LCD Display each 1 second and send this data to a Cloud Server every 60 seconds. 
\section{Experimental procedure}
Connect the sensor and LCD Display on your breadboard as we did in the previous lessons. 
\section{Creating the Thingspeak account }
Before we start to create an application, let's create our account on the website Thingspeak. We will go to use this website to receive and store the data.

Follow this tutorial to create your account and your channel:

\textcode{https://roboindia.com/tutorials/thingspeak-setup}

Once you've created your channel, you need to enable three channels on it. Let's use  Field1 to Temperature, Field2 to Humidity and Field3 to Pressure. You can see in Picture \ref{ThingspeakChannelConf} how your channel will look like.


\begin{figure}

\begin{center}
\includegraphics[width=0.85\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap12BuildingaMiniWeatherStation/figures/pharothings-thingspeak-conf.png}\caption{ThingSpeak Channel Configuration.\label{ThingspeakChannelConf}}\end{center}
\end{figure}


You can test your channel by simulating sending some data to it. Let's for example send the values:

\begin{itemize}
\item 25 to Temperature field (field1);
\item 56 to Humidity field (field2);
\item and 1012 to Pressure field (field3).
\end{itemize}

Just copy the following URI and passed in your web browser, changing YOUR-WRITE-API-KEY to your ThingSpeak write API code. You can find it in the API Keys tab. 

\textcode{https://api.thingspeak.com/update?api\_key=YOUR-WRITE-API-KEY\&
field1=25\&field2=56\&field3=1012}

So check you channel to see if it was updated with this values:

\textcode{https://thingspeak.com/channels/YOUR-CHANNEL-ID}
\section{Creating the application}
The first step lets create a Superclass to initialize and install all devices that we will use. So let's create 2 subclasses to do the actions. The first will display this information on the LCD and the second will send the data to the cloud. Your final code will seem like the Picture \ref{MiniWeatherStationcode}.


\begin{figure}

\begin{center}
\includegraphics[width=0.85\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap12BuildingaMiniWeatherStation/figures/pharothings-weather-station.png}\caption{Mini Weather Station code.\label{MiniWeatherStationcode}}\end{center}
\end{figure}

\section{Creating the Superclass}
\begin{displaycode}{plain}
Object subclass: #WeatherStation
    instanceVariableNames: 'sensor lcd'
    classVariableNames: ''
    package: 'PharoThings-MiniWeatherStation'
\end{displaycode}
\subsection{Creating the initialize method}
\begin{displaycode}{plain}
initialize
lcd := (RpiBoard3B current) installDevice: PotLCD1602Device  new.
sensor := (RpiBoard3B current) installDevice: PotBME280Device new. 
\end{displaycode}
\subsection{Creating access methods}
\begin{displaycode}{plain}
humidity
    ^((sensor readParameters at: 3) printShowingDecimalPlaces: 2) asString. 
\end{displaycode}

\begin{displaycode}{plain}
pressure
    ^((sensor readParameters at: 2) printShowingDecimalPlaces: 2) asString. 
\end{displaycode}

\begin{displaycode}{plain}
temperature 
    ^((sensor readParameters at: 1) printShowingDecimalPlaces: 2) asString.
\end{displaycode}
\section{Creating the subclass DisplayLCD}
\begin{displaycode}{plain}
WeatherStation subclass: #DisplayLCD
    instanceVariableNames: 'lcdprocess'
    classVariableNames: ''
    package: 'PharoThings-MiniWeatherStation'
\end{displaycode}

\begin{displaycode}{plain}
lcdStart
    |text|
    lcdprocess :=  [ [        
    text := 'Temp: ',self temperature,'\H:',self humidity,' P:',self pressure. 
    lcd home. 
    lcd message: text. 
    (Delay forSeconds: 1) wait. 
    ] repeat ] forkNamed: 'lcdprocess'. 
\end{displaycode}

\begin{displaycode}{plain}
lcdStop
    lcdprocess terminate. 
    lcd clear.
\end{displaycode}
\section{Creating the subclass PostData}
\begin{displaycode}{plain}
WeatherStation subclass: #PostData
	instanceVariableNames: 'apiKey postProcess'
	classVariableNames: ''
	package: 'PharoThings-MiniWeatherStation'
\end{displaycode}

\begin{displaycode}{plain}
apiKey
    ^apiKey
\end{displaycode}

\begin{displaycode}{plain}
apiKey: anString    
    apiKey := anString .
\end{displaycode}

\begin{displaycode}{plain}
dataStart
    |url uri |
    url := 'https://api.thingspeak.com/update'.
    postProcess :=  [ [        
        uri := url,'?api_key=',self apiKey,'&field1=',self temperature,'&field2=',self humidity,'&field3=',self pressure.
        ZnClient new get: uri.
    (Delay forSeconds: 60) wait. 
    ] repeat ] forkNamed: 'postprocess'. 
\end{displaycode}

\begin{displaycode}{plain}
dataStop
    postProcess terminate. 
\end{displaycode}
\section{Starting the application}
To start the application, we need to start the two subclasses. To start the LCD application run this in the remote playground:

\begin{displaycode}{plain}
(DisplayLCD new) lcdStart.
\end{displaycode}

and to start to send the data to the Cloud, use this, replacing to your apiKey of Thingspeak:

\begin{displaycode}{plain}
(PostData new) apiKey:'F1MKEG7PJ44930L8'; dataStart.
\end{displaycode}
\section{Visualizating your data}
To see if your channel is receiving the data of your PharoThings, just access your channel and check if the data is being updated:

\textcode{https://thingspeak.com/channels/YOUR-CHANNEL-ID}

You will see some grafics like the Picture \ref{ThingspeakChannel}. 


\begin{figure}

\begin{center}
\includegraphics[width=0.85\textwidth]{/Users/allexoliveira/PharoThingsBook/Booklet-APharoThingTutorial/_result/pdf/Chapters/Chap12BuildingaMiniWeatherStation/figures/pharothings-thingspeak.png}\caption{ThingSpeak Channel.\label{ThingspeakChannel}}\end{center}
\end{figure}




% lulu requires an empty page at the end. That's why I'm using
% \backmatter here.
\backmatter

% Index would go here

\end{document}
